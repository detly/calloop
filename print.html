<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A Guide to Calloop</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="ch00-00-where-to-start.html">Where to start</a></li><li class="chapter-item expanded "><a href="ch01-00-how-an-event-loop-works.html"><strong aria-hidden="true">1.</strong> How an event loop works</a></li><li class="chapter-item expanded "><a href="ch02-00-a-simple-example.html"><strong aria-hidden="true">2.</strong> A simple example</a></li><li class="chapter-item expanded "><a href="ch03-00-a-full-example-zeromq.html"><strong aria-hidden="true">3.</strong> A full example: ZeroMQ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-composition.html"><strong aria-hidden="true">3.1.</strong> Composition</a></li><li class="chapter-item expanded "><a href="ch03-02-creating-our-source-part-1-our-types.html"><strong aria-hidden="true">3.2.</strong> Creating our source, part I: our types</a></li><li class="chapter-item expanded "><a href="ch03-03-creating-our-source-part-2-setup-methods.html"><strong aria-hidden="true">3.3.</strong> Creating our source, part II: setup methods</a></li><li class="chapter-item expanded "><a href="ch03-04-creating-our-source-part-3-processing-events-almost.html"><strong aria-hidden="true">3.4.</strong> Creating our source, part III: processing events (almost)</a></li><li class="chapter-item expanded "><a href="ch03-05-creating-our-source-part-4-processing-events-really.html"><strong aria-hidden="true">3.5.</strong> Creating our source, part IV: processing events (really)</a></li><li class="chapter-item expanded "><a href="ch03-06-the-full-zeromq-event-source-code.html"><strong aria-hidden="true">3.6.</strong> The full ZeroMQ event source code</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">A Guide to Calloop</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/detly/calloop/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="where-to-start"><a class="header" href="#where-to-start">Where to start</a></h1>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<p>If you're familiar with event loops and the concepts involved, you can read <a href="api">the API docs</a> (they're also <a href="https://docs.rs/calloop/">hosted on <code>docs.rs</code></a>).</p>
<h2 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h2>
<p>If you don't know where to start, start here with these tutorials!</p>
<h2 id="example-code"><a class="header" href="#example-code">Example code</a></h2>
<p>If you want to see what Calloop code might look like, there's:</p>
<ul>
<li>a <a href="ch02-00-a-simple-example.html#the-whole-program">simple example</a> using only a timer and a callback</li>
<li>a <a href="ch03-06-the-full-zeromq-event-source-code">ZeroMQ event source</a> which shows how to combine event sources into something more complex</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="how-an-event-loop-works"><a class="header" href="#how-an-event-loop-works">How an event loop works</a></h1>
<p>An event loop is one way to write <em>concurrent</em> code. Other ways include threading (sort of), or asynchronous syntax.</p>
<p>When you write concurrent code, you need to know two things:</p>
<ul>
<li>where in your program it could potentially <em>block</em>, and</li>
<li>how to let other parts of your program run while waiting for those operations to stop blocking</li>
</ul>
<p>This chapter covers what the first thing means, and how Calloop accomplishes the second thing.</p>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<p>A <em>blocking</em> operation is not just something that can take a long time — it's anything that could take an <em>indefinite</em> amount of time. If you're reading data over the network, for example, you might have no idea how long you'll be waiting to receive the next packet. A millisecond? A second? An hour? Forever?</p>
<p>Examples of blocking operations are:</p>
<ul>
<li>timers</li>
<li>reading or writing to a file</li>
<li>reading or writing to a network socket</li>
<li>running other asynchronous code</li>
<li>waiting for a thread to finish</li>
</ul>
<p>When any of these operations are ready to go, we call it an <em>event</em>. We call the underlying things (files, network sockets, etc.) <em>sources</em> for events. So, for example, you can create an event source that corresponds to a file, and it will generate events when it is ready for reading, or writing, or encounters an error.</p>
<h2 id="events-and-callbacks"><a class="header" href="#events-and-callbacks">Events and callbacks</a></h2>
<p>An event loop like Calloop, as the name suggests, runs in a loop.  At the start of the loop, Calloop checks all the sources you've added to see if any events have happened for those sources. If they have, Calloop will call a function that you provide (known as a <em>callback</em>).</p>
<p>This function will (possibly) be given some data for the event itself (eg. the bytes received), some state for the event source (eg. the socket, or a type that wraps it in a neater API), and some state for the whole program.</p>
<p>Calloop will do this one by one for each source that has a new event. If a file is ready for reading, your file-event-source callback will be called. If a timer has elapsed, your timer-event-source callback will be called.</p>
<p>It is up to you to write the code to do things when events happen. For example, your callback might read data from a file &quot;ready for reading&quot; event into a queue. When the queue contains a valid message, the same callback could send that message over an internal channel to another event source. That second event source could have its own callback that processes entire messages and updates the program's state. And so on.</p>
<h2 id="concurrency-vs-parallelism"><a class="header" href="#concurrency-vs-parallelism">Concurrency vs parallelism</a></h2>
<p>This &quot;one by one&quot; nature of event loops is important. When you approach concurrency using threads, operations in any thread can be interleaved with operations in any other thread. This is typically made robust by either passing messages or using shared memory with synchronisation.</p>
<p>Callbacks in an event loop do not run in parallel, they run one after the other. Unless you (or your dependencies) have introduced threading, you can (and should) write your callbacks as single-threaded code.</p>
<h2 id="event-loops-vs-async-code"><a class="header" href="#event-loops-vs-async-code">Event loops vs async code</a></h2>
<p>This single-threaded nature makes event loops much more similar to code that uses <code>async</code>/<code>await</code> than to multithreaded code. There are benefits and tradeoffs to either approach.</p>
<p>Calloop will take care of a lot of integration and error handling boilerplate for you. It also makes it clearer what parts of your code are the non-blocking actions to perform as a result of events. If you like to think of your program in terms of taking action in reaction to events, this can be a great advantage!</p>
<p>However, this comes at the expense of needing to make your program's state much more explicit. For example, take this async code:</p>
<pre><code class="language-rust noplayground">do_thing_one().await;
do_thing_two().await;
do_thing_three().await;
</code></pre>
<p>The state of the program is simply given by: what line is it up to? You know if it's done &quot;thing one&quot; because execution has proceeded to line two. No other state is required. In Calloop, however, you will need extra variables and code so that when your callback is called, it knows whether to run <code>do_thing_one()</code>, <code>do_thing_two()</code>, or <code>do_thing_three()</code>.</p>
<h2 id="never-block-the-loop"><a class="header" href="#never-block-the-loop">Never block the loop!</a></h2>
<p>Both of the above principles lead us to the most important rule of event loop code: <strong>never block the loop!</strong> This means: never use blocking calls inside one of your event callbacks. Do not use synchronous file <code>write()</code> calls in a callback. Do not <code>sleep()</code> in a callback. Do not <code>join()</code> a thread in a callback. Don't you do it!</p>
<p>If you do, the event loop will have no way to proceed, and just... wait for your blocking operation to complete. Nothing is going to run in a parallel thread. Nothing is going to stop your callback and move on to the next one. If your callback needs to wait for a blocking operation, your code must allow it to keep track of where it's up to, return from the callback, and wait for the event like any other.</p>
<h2 id="calloop-and-composition"><a class="header" href="#calloop-and-composition">Calloop and composition</a></h2>
<p>Calloop is designed to work by <em>composition</em>. This means that you build up more complex logic in your program by combining simpler event sources. Want a network socket with custom backoff/timeout logic? Create a type containing a network socket from the <a href="../api/io/">async IO adapter</a>, a <a href="../api/timer">timer</a>, and add your backoff state logic. There is a much more detailed example of composition in our <a href="ch03-00-a-full-example-zeromq.html">ZeroMQ example</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="a-simple-example"><a class="header" href="#a-simple-example">A simple example</a></h1>
<p>The simplest way to use Calloop is to create the event sources it provides, and add them to the event loop with a callback function. When the event source has new events to process, your callback will be called.</p>
<p>Let's create a program that waits for five seconds, prints a message, and exits. If you've already read the <code>README</code> file or <a href="api">API docs</a>, this will look familiar.</p>
<h2 id="the-timer-event-source"><a class="header" href="#the-timer-event-source">The timer event source</a></h2>
<p>The first thing we need is an event source — that is, a type that implements the trait <code>calloop::EventSource</code>. If we look under <code>calloop::timer</code> we'll see the appropriately named <code>Timer</code>.</p>
<p><code>Timer</code> follows a pattern you'll see used for almost all event sources in Calloop. There is an event source (<code>Timer</code>) that is inserted into the loop. But there is also some other type (in this case, <code>TimerHandle</code>) that allows you to control or configure that source even after the loop has taken ownership of the source itself. For example:</p>
<ul>
<li>
<p>there is an MPSC (multiple producer, single consumer) channel that acts as an event source; the &quot;control&quot; end is simply the sending end of the channel</p>
</li>
<li>
<p>there is an <code>async</code> executor that acts as an event source; it is created along with a scheduler which lets you add <code>Future</code>s</p>
</li>
<li>
<p>the <code>Timer</code> can give you a <code>TimerHandle</code>, which lets you set or cancel timeouts</p>
</li>
</ul>
<p>So with <code>use calloop::timer::Timer</code> at the top of our <code>.rs</code> file, we just need to do:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use calloop::{timer::Timer, EventLoop, LoopSignal};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut event_loop: EventLoop&lt;LoopSignal&gt; =
</span><span class="boring">        EventLoop::try_new()
</span><span class="boring">            .expect(&quot;Failed to initialize the event loop!&quot;);
</span><span class="boring">
</span>    let source = Timer::new()
        .expect(&quot;Failed to create timer event source!&quot;);

    let timer_handle = source.handle();
    timer_handle
        .add_timeout(Duration::from_secs(5), &quot;Timeout reached!&quot;);
<span class="boring">
</span><span class="boring">    let handle = event_loop.handle();
</span><span class="boring">
</span><span class="boring">    handle
</span><span class="boring">        .insert_source(
</span><span class="boring">            source,
</span><span class="boring">            |event, _metadata, shared_data| {
</span><span class="boring">                println!(&quot;Event fired: {}&quot;, event);
</span><span class="boring">                shared_data.stop();
</span><span class="boring">            },
</span><span class="boring">        )
</span><span class="boring">        .expect(&quot;Failed to insert event source!&quot;);
</span><span class="boring">
</span><span class="boring">    let mut shared_data = event_loop.get_signal();
</span><span class="boring">
</span><span class="boring">    event_loop
</span><span class="boring">        .run(None, &amp;mut shared_data, |_shared_data| {})
</span><span class="boring">        .expect(&quot;Error during event loop!&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>Many methods in Calloop return a <code>Result</code> because creating these sources is inherently risky — most event sources require some kind of underlying operating system resource, which can potentially be exhausted. You will have to decide how to handle such errors.</p>
<p>An extremely important thing to note about our timer handle here is that we are not constrained to use it before we run our event loop. We may call methods on it from other event callbacks, we may clone it and even use it in other threads or futures to dynamically control the <code>Timer</code> that is now part of the event loop.</p>
<h2 id="calloops-type-parameters"><a class="header" href="#calloops-type-parameters">Calloop's type parameters</a></h2>
<p>The second argument to <code>add_timeout()</code> deserves extra attention. Calloop has a few different type parameters that you'll need to know about to use it properly. The two most important are:</p>
<ul>
<li>
<p>The event loop itself, <code>EventLoop</code>, is parameterised by the type of the shared data that all callbacks receive. This will probably correspond to the &quot;high level&quot; state of your program.</p>
</li>
<li>
<p>Event sources ie. implementations of <code>EventSource</code>, have an associated type <code>Event</code>. This differs from source to source, and always relates to the &quot;control side&quot; of the source.</p>
</li>
</ul>
<p>In the case of a timer, <code>Timer::Event</code> is the type of data that you give to the handle: here it is <code>&amp;'static str</code>. But what about <code>EventLoop</code>'s type parameter? Well, since we want to exit the program after the timer fires, the high level &quot;state&quot; of our program is simply whether our loop is running or not. This is easily controlled by the <code>LoopSignal</code> value that <code>EventLoop::get_signal()</code> provides us, which has a <code>stop()</code> method. So let's make this our shared state:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use calloop::{timer::Timer, EventLoop, LoopSignal};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let mut event_loop: EventLoop&lt;LoopSignal&gt; =
        EventLoop::try_new()
            .expect(&quot;Failed to initialize the event loop!&quot;);
<span class="boring">
</span><span class="boring">    let source = Timer::new()
</span><span class="boring">        .expect(&quot;Failed to create timer event source!&quot;);
</span><span class="boring">
</span><span class="boring">    let timer_handle = source.handle();
</span><span class="boring">    timer_handle
</span><span class="boring">        .add_timeout(Duration::from_secs(5), &quot;Timeout reached!&quot;);
</span><span class="boring">
</span><span class="boring">    let handle = event_loop.handle();
</span><span class="boring">
</span><span class="boring">    handle
</span><span class="boring">        .insert_source(
</span><span class="boring">            source,
</span><span class="boring">            |event, _metadata, shared_data| {
</span><span class="boring">                println!(&quot;Event fired: {}&quot;, event);
</span><span class="boring">                shared_data.stop();
</span><span class="boring">            },
</span><span class="boring">        )
</span><span class="boring">        .expect(&quot;Failed to insert event source!&quot;);
</span><span class="boring">
</span><span class="boring">    let mut shared_data = event_loop.get_signal();
</span><span class="boring">
</span><span class="boring">    event_loop
</span><span class="boring">        .run(None, &amp;mut shared_data, |_shared_data| {})
</span><span class="boring">        .expect(&quot;Error during event loop!&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>This is just the type annotation — something that Rust could infer itself, but it's often helpful to make it explicit here to avoid confusing error messages if you get it wrong in callbacks or method calls. The actual data is provided when we run the loop:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use calloop::{timer::Timer, EventLoop, LoopSignal};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut event_loop: EventLoop&lt;LoopSignal&gt; =
</span><span class="boring">        EventLoop::try_new()
</span><span class="boring">            .expect(&quot;Failed to initialize the event loop!&quot;);
</span><span class="boring">
</span><span class="boring">    let source = Timer::new()
</span><span class="boring">        .expect(&quot;Failed to create timer event source!&quot;);
</span><span class="boring">
</span><span class="boring">    let timer_handle = source.handle();
</span><span class="boring">    timer_handle
</span><span class="boring">        .add_timeout(Duration::from_secs(5), &quot;Timeout reached!&quot;);
</span><span class="boring">
</span><span class="boring">    let handle = event_loop.handle();
</span><span class="boring">
</span><span class="boring">    handle
</span><span class="boring">        .insert_source(
</span><span class="boring">            source,
</span><span class="boring">            |event, _metadata, shared_data| {
</span><span class="boring">                println!(&quot;Event fired: {}&quot;, event);
</span><span class="boring">                shared_data.stop();
</span><span class="boring">            },
</span><span class="boring">        )
</span><span class="boring">        .expect(&quot;Failed to insert event source!&quot;);
</span><span class="boring">
</span>    let mut shared_data = event_loop.get_signal();

    event_loop
        .run(None, &amp;mut shared_data, |_shared_data| {})
        .expect(&quot;Error during event loop!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>The callback provided in the <code>run()</code> method is for when the loop is idle, which we're not using here.</p>
<h2 id="adding-sources-to-the-loop"><a class="header" href="#adding-sources-to-the-loop">Adding sources to the loop</a></h2>
<p>We have an event source, we have our shared data, and we know how to start our loop running. All that is left is to learn how to combine these things:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use calloop::{timer::Timer, EventLoop, LoopSignal};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut event_loop: EventLoop&lt;LoopSignal&gt; =
</span><span class="boring">        EventLoop::try_new()
</span><span class="boring">            .expect(&quot;Failed to initialize the event loop!&quot;);
</span><span class="boring">
</span><span class="boring">    let source = Timer::new()
</span><span class="boring">        .expect(&quot;Failed to create timer event source!&quot;);
</span><span class="boring">
</span><span class="boring">    let timer_handle = source.handle();
</span><span class="boring">    timer_handle
</span><span class="boring">        .add_timeout(Duration::from_secs(5), &quot;Timeout reached!&quot;);
</span><span class="boring">
</span>    let handle = event_loop.handle();

    handle
        .insert_source(
            source,
            |event, _metadata, shared_data| {
                println!(&quot;Event fired: {}&quot;, event);
                shared_data.stop();
            },
        )
        .expect(&quot;Failed to insert event source!&quot;);
<span class="boring">
</span><span class="boring">    let mut shared_data = event_loop.get_signal();
</span><span class="boring">
</span><span class="boring">    event_loop
</span><span class="boring">        .run(None, &amp;mut shared_data, |_shared_data| {})
</span><span class="boring">        .expect(&quot;Error during event loop!&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>Breaking this down:</p>
<ul>
<li>
<p>We obtain a handle from the event loop. Much like the timer handle above, this is a separate type from the event loop and allows us to insert sources from event callbacks, other threads, and futures.</p>
</li>
<li>
<p>We insert the source using <code>LoopHandle::insert_source()</code>.</p>
</li>
<li>
<p>When we insert the source we also provide a callback that will be called on every event generated by the event source. This callback will take the event specific data (our <code>&amp;'static str</code>), some source-specific data (the timer's handle) and the shared loop data (a <code>LoopSignal</code>).</p>
</li>
</ul>
<p>Our callback does the two things we want to do when five seconds have elapsed: print a message, and stop the loop.</p>
<p>Once the loop stops, the <code>run()</code> call will exit and so will <code>main()</code>.</p>
<h2 id="the-whole-program"><a class="header" href="#the-whole-program">The whole program</a></h2>
<p>Putting it all together, we have:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use calloop::{timer::Timer, EventLoop, LoopSignal};

fn main() {
    let mut event_loop: EventLoop&lt;LoopSignal&gt; =
        EventLoop::try_new()
            .expect(&quot;Failed to initialize the event loop!&quot;);

    let source = Timer::new()
        .expect(&quot;Failed to create timer event source!&quot;);

    let timer_handle = source.handle();
    timer_handle
        .add_timeout(Duration::from_secs(5), &quot;Timeout reached!&quot;);

    let handle = event_loop.handle();

    handle
        .insert_source(
            source,
            |event, _metadata, shared_data| {
                println!(&quot;Event fired: {}&quot;, event);
                shared_data.stop();
            },
        )
        .expect(&quot;Failed to insert event source!&quot;);

    let mut shared_data = event_loop.get_signal();

    event_loop
        .run(None, &amp;mut shared_data, |_shared_data| {})
        .expect(&quot;Error during event loop!&quot;);
}
</code></pre></pre>
<h2 id="what-next"><a class="header" href="#what-next">What next?</a></h2>
<p>Of course, this is all a bit more wordy than simply <code>std::thread::sleep()</code>, so what have we achieved?</p>
<p>The next couple of chapters will show how we can create our own event sources through <em>composition</em>, and how to use handles and events in more complex ways.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="a-full-example-zeromq"><a class="header" href="#a-full-example-zeromq">A full example: ZeroMQ</a></h1>
<p>The previous chapter showed how to use callbacks, event data and shared data to control our program. However, more complex programs will require more complex shared data, and more complex interactions between events. Eventually this will run up against ownership issues and just the basic mental load of the poor programmer.</p>
<p>In this chapter we're going to create a more complex program: one based on <a href="https://zeromq.org/">ZeroMQ sockets</a>.</p>
<p>ZeroMQ is (very) basically a highly abstracted socket library. You can create ZeroMQ sockets over TCP, PGM, IPC, in-process and more, and generally not worry about the transport mechanics. It guarantees atomic message transfer, and handles queuing, retries, reconnection and balancing under the hood. It <strong>also</strong> lets you integrate it with event loops and reactors by exposing a file descriptor that you can wait on.</p>
<p>But we can't just wrap this file descriptor in Calloop's <code>generic::Generic</code> source and be done — there are a few subtleties we need to take care of for it to work right and be useful.</p>
<blockquote>
<h2 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h2>
<p>It might be tempting, at the end of this chapter, to think that the code we've written is <em>the</em> definitive ZeroMQ wrapper, able to address any use case or higher level pattern you like. Certainly it will be a lot more suited to Calloop than using ZeroMQ sockets by themselves, but it is not the only way to use them with Calloop. Here are some things I have not addressed, for the sake of simplicity:</p>
<ul>
<li>We will not handle fairness — our code will totally monopolise the event loop if we receive many messages at once.</li>
<li>We do not consider <a href="https://lucumr.pocoo.org/2020/1/1/async-pressure/">back pressure</a> beyond whatever built-in zsocket settings the caller might use.</li>
<li>We just drop pending messages in the zsocket's internal queue (in and out) on shutdown. In a real application, you might want to make more specific decisions about the timeout and linger periods before dropping the zsocket, depending on your application's requirements.</li>
<li>We don't deal with zsocket errors much. In fact, the overall error handling of event sources is usually highly specific to your application, so what we end up writing here is almost certainly not going to survive contact with your own code base. Here we just use <code>?</code> everywhere, which will eventually cause the event loop to exit with an error.</li>
</ul>
<p>So by all means, take the code we write here and use and adapt it, but please <em>please</em> note the caveats above and think carefully about your own program.</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="composing-event-sources"><a class="header" href="#composing-event-sources">Composing event sources</a></h1>
<p>Calloop is designed to work by <em>composition</em>. It provides you with some single-responsibility sources (timers, message channels, file descriptors), and you can combine these together bit by bit to make more complex sources. You can greatly simplify even a highly complex program if you identify and expose the &quot;real&quot; events you care about and use composition to tidy the other events away in internal details of event sources.</p>
<p>So what do we need to compose?</p>
<h2 id="the-generic-source"><a class="header" href="#the-generic-source">The generic source</a></h2>
<p>Most obviously, ZeroMQ exposes a file descriptor for us to use. (This is a common thing for event-related libraries to do, so if you're wondering how to integrate, say, I²C or GPIO on Linux with Calloop, that's your answer.)</p>
<p>Calloop can use file descriptors via the <code>calloop::generic::Generic</code> source. So that's one.</p>
<h2 id="the-mpsc-channel-source"><a class="header" href="#the-mpsc-channel-source">The MPSC channel source</a></h2>
<p>Secondly, we might want to send messages on the socket. This means our event source needs to react when we send it a message. Calloop has a message channel for precisely this purpose: <code>calloop::channel::Channel</code>. That's another one.</p>
<h2 id="the-wakeup-call"><a class="header" href="#the-wakeup-call">The wakeup call</a></h2>
<p>The third event source we need is a bit subtle, but since this isn't a mystery novel I can save you hours of debugging and spoil the ending now: we need a &quot;ping&quot; event source because ZeroMQ's FD is edge triggered.</p>
<p><a href="http://api.zeromq.org/master:zmq-getsockopt#toc11">ZeroMQ's file descriptor</a> is not the FD of an actual file or socket — you do not actually read data from it. It exists as an interface, with three important details:</p>
<ul>
<li>
<p>It is only ever readable. Even if the underlying socket can be written to, the FD that ZeroMQ gives you signals this by becoming readable. In fact, this FD will become readable under three circumstances: the ZeroMQ socket (henceforth called a &quot;zsocket&quot;) is readable, writeable, or has an error. There is a separate function call, <code>zmq::Socket::get_events()</code> that will tell you which.</p>
</li>
<li>
<p><strong>It is edge triggered.</strong> It will only ever change from not-readable to readable when the socket's state changes. So if a zsocket receives two messages, and you only read one, <strong>the file descriptor will not wake up the event loop again</strong>. Why not? Because it hasn't changed state! After you read one message, the zsocket still has events waiting. If it receives yet another message... it still has events waiting. No change in internal state = no external event.</p>
</li>
<li>
<p>This edge triggering <strong>also covers user actions.</strong> If a zsocket becomes writeable, and then you write to the zsocket, it might immediately (and atomically) change from writeable to readable. In this case <strong>you will not get another event on the FD</strong>.</p>
</li>
</ul>
<p>(The docs make this quite explicit, but there's a lot of docs to read so I'm spelling it out here.)</p>
<p>What this adds up to is this: when we create our zsocket, it might already be readable or writeable. So when we add it to our event loop, it won't fire any events. Our entire source will just sit there until we wake it up by sending a message (which we might never do if it's eg. a pull socket).</p>
<p>So the last event source we need is something that doesn't really convey any kind of message except &quot;please wake up the event loop on the next iteration&quot;, and that is exactly what a <code>calloop::ping::PingSource</code> does. And that's three.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="creating-our-source-part-i-our-types"><a class="header" href="#creating-our-source-part-i-our-types">Creating our source, part I: our types</a></h1>
<p>In the last chapter we worked out a list of the event sources we need to compose into a new type:</p>
<ol>
<li><code>calloop::generic::Generic</code></li>
<li><code>calloop::channel::Channel</code></li>
<li><code>calloop::ping::Ping</code></li>
</ol>
<p>So at a minimum, our type needs to contain these:</p>
<pre><code class="language-rust noplayground">pub struct ZeroMQSource
{
    // Calloop components.
    socket_source: calloop::generic::Generic&lt;calloop::generic::Fd&gt;,
    mpsc_receiver: calloop::channel::Channel&lt;?&gt;,
    wake_ping_receiver: calloop::ping::PingSource,
}
</code></pre>
<p>Note that I've left the type for the channel as <code>?</code> — we'll get to that a bit later.</p>
<p>What else do we need? If the <code>PingSource</code> is there to wake up the loop manually, we need to keep the other end of it. The ping is an internal detail — users of our type don't need to know it's there. We also need the zsocket itself, so we can actually detect and process events on it. That gives us:</p>
<pre><code class="language-rust noplayground">pub struct ZeroMQSource
{
    // Calloop components.
    socket_source: calloop::generic::Generic&lt;calloop::generic::Fd&gt;,
    mpsc_receiver: calloop::channel::Channel&lt;?&gt;,
    wake_ping_receiver: calloop::ping::PingSource,

    /// Sending end of the ping source.
    wake_ping_sender: calloop::ping::Ping,

    /// The underlying ZeroMQ socket.
    socket: zmq::Socket,
}
</code></pre>
<h2 id="the-message-type"><a class="header" href="#the-message-type">The message type</a></h2>
<p>The most obvious candidate for the type of the message queue would be <code>zmq::Message</code>. But ZeroMQ sockets are capable of sending multipart messages, and this is even mandatory for eg. the <code>PUB</code> zsocket type, where the first part of the message is the topic.</p>
<p>Therefore it makes more sense to accept a sequence of messages to cover the most general case, and that sequence can have a length of one for single-part messages. But with one more tweak: we can accept a sequence of things that <em>can be transformed</em> into <code>zmq::Message</code> values. The exact type we'll use will be a generic type like so:</p>
<pre><code class="language-rust noplayground">pub struct ZeroMQSource&lt;T&gt;
where
    T: IntoIterator,
    T::Item: Into&lt;zmq::Message&gt;,
{
    mpsc_receiver: calloop::channel::Channel&lt;T&gt;,
	// ...
}
</code></pre>
<blockquote>
<h3 id="enforcing-single-messages"><a class="header" href="#enforcing-single-messages">Enforcing single messages</a></h3>
<p>Remember that it's not just <code>Vec&lt;T&gt;</code> and other sequence types that implement <code>IntoIterator</code> — <code>Option&lt;T&gt;</code> implements it too! There is also <code>std::iter::Once&lt;T&gt;</code>. So if a user of our API wants to enforce that at most (or exactly) one message is sent, they can use this API with <code>T</code> being, say, <code>Option&lt;zmq::Message&gt;</code>.</p>
</blockquote>
<h2 id="associated-types"><a class="header" href="#associated-types">Associated types</a></h2>
<p>The <code>EventSource</code> trait has three associated types:</p>
<ul>
<li>
<p><code>Event</code> - when an event is generated that our caller cares about (ie. not some internal thing), this is the data we provide to their callback. This will be another sequence of messages, but because we're constructing it we can be more opinionated about the type and use the return type of <code>zmq::Socket::recv_multipart()</code> which is <code>Vec&lt;Vec&lt;u8&gt;&gt;</code>.</p>
</li>
<li>
<p><code>Metadata</code> - this is a more persistent kind of data, perhaps the underlying file descriptor or socket, or maybe some stateful object that the callback can manipulate. It is passed by exclusive reference to the <code>Metadata</code> type. In our case we don't use this, so it's <code>()</code>.</p>
</li>
<li>
<p><code>Ret</code> - this is the return type of the callback that's called on an event. Usually this will be a <code>Result</code> of some sort; in our case it's <code>std::io::Result&lt;()&gt;</code> just to signal whether some underlying operation failed or not.</p>
</li>
</ul>
<p>So together these are:</p>
<pre><code class="language-rust noplayground">impl&lt;T&gt; calloop::EventSource for ZeroMQSource&lt;T&gt;
where
    T: IntoIterator,
    T::Item: Into&lt;zmq::Message&gt;,
{
    type Event = Vec&lt;Vec&lt;u8&gt;&gt;;
    type Metadata = ();
    type Ret = io::Result&lt;()&gt;;
    // ...
}
</code></pre>
<hr />
<p>I have saved one surprise for later to emphasise some important principles, but for now, let's move on to defining some methods!</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="creating-our-source-part-ii-setup-methods"><a class="header" href="#creating-our-source-part-ii-setup-methods">Creating our source, part II: setup methods</a></h1>
<p>Now that we've figured out the types we need, we can get to work writing some methods. We'll need to implement the methods defined in the <code>calloop::EventSource</code> trait, and a constructor function to create the source.</p>
<h2 id="our-constructor"><a class="header" href="#our-constructor">Our constructor</a></h2>
<p>Creating our source is fairly straightforward. We can let the caller set up the zsocket the way they need, and take ownership of it when it's initialised. Our caller needs not only the source itself, but the sending end of the MPSC channel so they can send messages, so we need to return that too.</p>
<p>A common pattern in Calloop's own constructor functions is to return a tuple containing (a) the source and (b) a type to use the source. So that's what we'll do:</p>
<pre><code class="language-rust noplayground">// Converts a `zmq::Socket` into a `ZeroMQSource` plus the sending end of an
// MPSC channel to enqueue outgoing messages.
pub fn from_socket(socket: zmq::Socket) -&gt; io::Result&lt;(Self, calloop::channel::Sender&lt;T&gt;)&gt; {
    let (mpsc_sender, mpsc_receiver) = calloop::channel::channel();
    let (wake_ping_sender, wake_ping_receiver) = calloop::ping::make_ping()?;

    let fd = socket.get_fd()?;

    let socket_source =
        calloop::generic::Generic::from_fd(fd, calloop::Interest::READ, calloop::Mode::Edge);

    Ok((
        Self {
            socket,
            socket_source,
            mpsc_receiver,
            wake_ping_receiver,
            wake_ping_sender,
        },
        mpsc_sender,
    ))
}
</code></pre>
<h2 id="trait-methods-registering-sources"><a class="header" href="#trait-methods-registering-sources">Trait methods: registering sources</a></h2>
<p>Calloop's event sources have a kind of life cycle, starting with <em>registration</em>. When you add an event source to the event loop, under the hood the source will <em>register</em> itself with the loop. Under certain circumstances a source will need to re-register itself. And finally there is the <em>unregister</em> action when an event source is removed from the loop. These are expressed via the <code>calloop::EventSource</code> methods:</p>
<ul>
<li><code>fn register(&amp;mut self, poll: &amp;mut calloop::Poll, token: calloop::Token) -&gt; std::io::Result&lt;()&gt;</code></li>
<li><code>fn reregister(&amp;mut self, poll: &amp;mut calloop::Poll, token: calloop::Token) -&gt; std::io::Result&lt;()&gt;</code></li>
<li><code>fn unregister(&amp;mut self, poll: &amp;mut calloop::Poll) -&gt; std::io::Result&lt;()&gt;</code></li>
</ul>
<p>The first two methods take a <em>token</em>, which is a way for your source to know why it was woken up. You can set the <code>sub_id</code> field to be different for each of your own internal sources, and check this in your <code>process_events()</code> function. Note that a <code>sub_id</code> of 0 corresponds to an event generated for the entire source, so your internal IDs should start at 1.</p>
<p>Let's define our token sub-IDs in the type's definition:</p>
<pre><code class="language-rust noplayground">impl&lt;T&gt; ZeroMQSource&lt;T&gt;
where
    T: IntoIterator,
    T::Item: Into&lt;zmq::Message&gt;,
{
    const ID_CHANNEL: u32 = 1;
    const ID_SOCKET: u32 = 2;
    const ID_WAKER: u32 = 3;
    // ...
}
</code></pre>
<p>We use these in our registration functions like so:</p>
<pre><code class="language-rust noplayground">    fn register(&amp;mut self, poll: &amp;mut calloop::Poll, token: calloop::Token) -&gt; io::Result&lt;()&gt; {
        let tk_socket = token.with_sub_id(Self::ID_SOCKET);
        let tk_channel = token.with_sub_id(Self::ID_CHANNEL);
        let tk_waker = token.with_sub_id(Self::ID_WAKER);

        self.socket_source.register(poll, tk_socket)?;
        self.mpsc_receiver.register(poll, tk_channel)?;
        self.wake_ping_receiver.register(poll, tk_waker)?;

        self.wake_ping_sender.ping();

        Ok(())
    }

    fn reregister(&amp;mut self, poll: &amp;mut calloop::Poll, token: calloop::Token) -&gt; io::Result&lt;()&gt; {
        let tk_socket = token.with_sub_id(Self::ID_SOCKET);
        let tk_channel = token.with_sub_id(Self::ID_CHANNEL);
        let tk_waker = token.with_sub_id(Self::ID_WAKER);

        self.socket_source.reregister(poll, tk_socket)?;
        self.mpsc_receiver.reregister(poll, tk_channel)?;
        self.wake_ping_receiver.reregister(poll, tk_waker)?;

        self.wake_ping_sender.ping();

        Ok(())
    }


fn unregister(&amp;mut self, poll: &amp;mut calloop::Poll) -&gt; std::io::Result&lt;()&gt; {
    self.socket_source.unregister(poll)?;
    self.mpsc_receiver.unregister(poll)?;
    self.wake_ping_receiver.unregister(poll)?;
    Ok(())
}
</code></pre>
<blockquote>
<p><strong>Note the <code>self.wake_ping_sender.ping()</code> call in the first two functions!</strong> This is how we manually prompt the event loop to wake up and run our source on the next iteration, to properly account for the <a href="ch03-01-composition.html#the-wakeup-call">zsocket's edge-triggering</a>.</p>
</blockquote>
<h2 id="our-drop-handler"><a class="header" href="#our-drop-handler">Our drop handler</a></h2>
<p>ZeroMQ sockets have their own internal queues and state, and therefore need a bit of care when shutting down. Depending on zsocket type and settings, when the ZeroMQ context is dropped, it could block waiting for certain operations to complete. We can write a drop handler to avoid this, but again <em>note that it's only one of many ways</em> to handle zsocket shutdown.</p>
<pre><code class="language-rust noplayground">impl&lt;T&gt; Drop for ZeroMQSource&lt;T&gt;
where
    T: IntoIterator,
    T::Item: Into&lt;zmq::Message&gt;,
{
    fn drop(&amp;mut self) {
        // This is one way to stop socket code (especially PUSH sockets) hanging
        // at the end of any blocking functions.
        //
        // - https://stackoverflow.com/a/38338578/188535
        // - http://api.zeromq.org/4-0:zmq-ctx-term
        self.socket.set_linger(0).ok();
        self.socket.set_rcvtimeo(0).ok();
        self.socket.set_sndtimeo(0).ok();

        // Double result because (a) possible failure on call and (b) possible
        // failure decoding.
        if let Ok(Ok(last_endpoint)) = self.socket.get_last_endpoint() {
            self.socket.disconnect(&amp;last_endpoint).ok();
        }
    }
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="creating-our-source-part-iii-processing-events-almost"><a class="header" href="#creating-our-source-part-iii-processing-events-almost">Creating our source, part III: processing events (almost)</a></h1>
<p>Finally, the real functionality we care about! Processing events! This is also a method in the <code>calloop::EventSource</code> trait:</p>
<pre><code class="language-rust noplayground">fn process_events&lt;F&gt;(
    &amp;mut self,
    readiness: calloop::Readiness,
    token: calloop::Token,
    mut callback: F,
) -&gt; io::Result&lt;()&gt;
where
    F: FnMut(Self::Event, &amp;mut Self::Metadata) -&gt; Self::Ret,
</code></pre>
<p>What a mouthful! But when you break it down, it's not so complicated:</p>
<ul>
<li>
<p>We take our own state, of course, as <code>&amp;mut self</code>.</p>
</li>
<li>
<p>We take a <code>Readiness</code> value - this is mainly useful for &quot;real&quot; file descriptors, and tells you whether the event source was woken up for a read or write event. We ignore it though, because our internal sources are always only readable (remember that even if the zsocket is writeable, the FD it exposes is only ever readable).</p>
</li>
<li>
<p>We take a token, just like our register/re-register methods. The ID will always correspond to our own source, but we can check the sub-ID to see which of our internal sources caused us to run.</p>
</li>
<li>
<p>We take a callback. We call this callback with any &quot;real&quot; events that our caller will care about; in our case, that means messages we receive on the zsocket. It is closely related to <a href="ch03-02-creating-our-source-part-1-our-types.html#associated-types">the <code>EventSource</code> trait's associated types</a>. Note that the callback our caller supplies when adding our source to the loop actually takes an extra argument, which is some data that we won't know about in our source. Calloop's internals take care of combining our arguments here with this extra data.</p>
</li>
</ul>
<p>Implementing this method simply involves asking a couple of questions: why was this event source woken up, and what should we do about it? (I mean, that's every function, isn't it? Why were we called and what do we do?)</p>
<p>We can answer the first question by looking at the <code>token</code> argument. If <code>token.sub_id</code> is <code>ID_WAKER</code>, we were woken up on registration. If it's <code>ID_CHANNEL</code>, we were woken up because we received a message. If it's <code>ID_SOCKET</code>, we were woken up because our zsocket file descriptor became readable.</p>
<p>The first thing to do is process these events. With a type that contains various Calloop sources composed together, like we have, we do this recursively by calling our internal sources' <code>process_events()</code> method.</p>
<p>So a first draft of our code might look like:</p>
<pre><code class="language-rust noplayground">fn process_events&lt;F&gt;(
    &amp;mut self,
    readiness: calloop::Readiness,
    token: calloop::Token,
    mut callback: F,
) -&gt; io::Result&lt;()&gt;
where
    F: FnMut(Self::Event, &amp;mut Self::Metadata) -&gt; Self::Ret,
{
    // We were woken up on startup/registration.
    if token.sub_id == Self::ID_WAKER {
        self.wake_ping_receiver
            .process_events(readiness, token, |_, _| {})?;
    }
    // We received a message over the MPSC channel.
    else if token.sub_id == Self::ID_CHANNEL {
        self.mpsc_receiver
            .process_events(readiness, token, |evt, _| {
				// 'evt' could be a message or a &quot;sending end closed&quot;
				// notification. We don't care about the latter.
                if let calloop::channel::Event::Msg(msg) = evt {
                    self.socket.send_multipart(msg, 0)?;
                }
            })?;
    }
	// The zsocket became read/write-able.
    else if token.sub_id == Self::ID_SOCKET {
        self.socket
            .process_events(readiness, token, |_, _| {
                let events = self.socket.get_events()?;
            
                if events.contains(zmq::POLLOUT) {
                    // Wait, what do we do here?
                }

                if events.contains(zmq::POLLIN) {
                    let messages = self.socket.recv_multipart(0)?;
                    callback(messages, &amp;mut ())?;
                }
            })?;
    }
    Ok(())
}
</code></pre>
<p>We process the events from whichever source woke up our composed source, and if we woke up because the zsocket became readable, we call the callback with the message we received.</p>
<p>Don't worry about getting this to compile, it is a good start but it's wrong in a few ways.</p>
<p>Firstly, we've gone to all the trouble of using a ping to wake up the source, and then we just... drain its internal events and return. Which achieves nothing.</p>
<p>Secondly, we don't seem to know what to do when our zsocket becomes writeable (the actual zsocket, not the &quot;interface&quot; file descriptor).</p>
<p>Thirdly, we commit one of the worst sins you can commit in an event-loop-based system. Can you see it? It's this part:</p>
<pre><code class="language-rust noplayground">else if token.sub_id == Self::ID_CHANNEL {
    self.mpsc_receiver
        .process_events(readiness, token, |evt, _| {
            if let calloop::channel::Event::Msg(msg) = evt {
                self.socket.send_multipart(msg, 0)?;
            }
        })?;
}
</code></pre>
<p>We block the event loop! In the middle of processing events from the MPSC channel, we call <code>zmq::Socket::send_multipart()</code> which <em>could</em>, under certain circumstances, block! <a href="ch01-00-how-an-event-loop-works.html#never-block-the-loop"><strong>We shouldn't do that.</strong></a></p>
<p>Let's deal with this badness first then. We want to decouple &quot;receiving messages over the MPSC channel&quot; from &quot;sending messages on the zsocket&quot;. There are different ways to do this, but they boil down to: buffer messages or drop messages (or maybe a combination of both). We'll use the first approach, with an internal FIFO queue. When we receive messages, we push them onto the back of the queue. When the zsocket is writeable, we pop messages from the front of the queue.</p>
<p>The standard library has <code>collections::VecDeque&lt;T&gt;</code> which provides efficient double-ended queuing, so let's use that. This is some extra internal state, so we need to add it to our type, which becomes:</p>
<pre><code class="language-rust noplayground">pub struct ZeroMQSource&lt;T&gt;
where
    T: IntoIterator,
    T::Item: Into&lt;zmq::Message&gt;,
{
    // Calloop components.
    socket_source: calloop::generic::Generic&lt;calloop::generic::Fd&gt;,
    mpsc_receiver: calloop::channel::Channel&lt;T&gt;,
    wake_ping_receiver: calloop::ping::PingSource,

    /// Sending end of the ping source.
    wake_ping_sender: calloop::ping::Ping,

    /// The underlying ZeroMQ socket.
    socket: zmq::Socket,

    /// FIFO queue for the messages to be published.
    outbox: std::collections::VecDeque&lt;T&gt;,
}
</code></pre>
<p>Our MPSC receiving code becomes:</p>
<pre><code class="language-rust noplayground">else if token.sub_id == Self::ID_CHANNEL {
    let outbox = &amp;mut self.outbox;

    self.mpsc_receiver
        .process_events(readiness, token, |evt, _| {
            if let calloop::channel::Event::Msg(msg) = evt {
                outbox.push_back(msg);
            }
        })?;
}
</code></pre>
<p>And our &quot;zsocket is writeable&quot; code becomes:</p>
<pre><code class="language-rust noplayground">else if token.sub_id == Self::ID_SOCKET {
    self.socket
        .process_events(readiness, token, |_, _| {
            let events = self.socket.get_events()?;
        
            if events.contains(zmq::POLLOUT) {
                if let Some(parts) = self.outbox.pop_front() {
                    self.socket
                        .send_multipart(parts, 0)?;
                }
           }

            if events.contains(zmq::POLLIN) {
                let messages = self.socket.recv_multipart(0)?;
                callback(messages, &amp;mut ())?;
            }
        })?;
}
</code></pre>
<p>So we've not only solved problem #3, we've also figured out #2, which suggests we're on the right track. But we still have (at least) that first issue to sort out.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="creating-our-source-part-iv-processing-events-really"><a class="header" href="#creating-our-source-part-iv-processing-events-really">Creating our source, part IV: processing events (really)</a></h1>
<p>We have three events that could wake up our event source: the ping, the channel and the zsocket itself becoming ready to use. <em>All three of these reasons</em> potentially mean doing something on the zsocket: if the ping fired, we need to check for any pending events. If the channel received a message, we want to check if the zsocket is already readable and send it. If the zsocket becomes readable or writeable, we want to read from or write to it.</p>
<p>When you think about it this way... why do we even need to check for the zsocket token sub ID? We want to run it every time! So our first job is to get rid of the <code>else if token.sub_id == Self::ID_SOCKET</code> block:</p>
<pre><code class="language-rust noplayground">self.socket
    .process_events(readiness, token, |_, _| {
        let events = self.socket.events()?;
    
        if events.contains(zmq::POLLOUT) {
            if let Some(parts) = self.outbox.pop_front() {
                self.socket
                    .send_multipart(parts, 0)?;
            }
        }

        if events.contains(zmq::POLLIN) {
            let messages = self.socket.recv_multipart(0)?;
            callback(messages, &amp;mut ())?;
        }
    })?;

</code></pre>
<p>We're not done yet. There's some more cruft to remove. Notice that in the zsocket <code>process_events()</code> call, we don't use any of the arguments. This is also true for our ping source, but there's an important difference: the ping source is &quot;level triggered&quot;, which means that if we don't process its internal events, it will just keep waking up our source forever. Our zsocket source is edge triggered, so we can dispense with <code>process_events()</code> call altogether:</p>
<pre><code class="language-rust noplayground">let events = self.socket.events()?;

if events.contains(zmq::POLLOUT) {
    if let Some(parts) = self.outbox.pop_front() {
        self.socket
            .send_multipart(parts, 0)?;
    }
}

if events.contains(zmq::POLLIN) {
    let messages = self.socket.recv_multipart(0)?;
    callback(messages, &amp;mut ())?;
}
</code></pre>
<p>So the second draft of our <code>process_events()</code> function is now:</p>
<pre><code class="language-rust noplayground">fn process_events&lt;F&gt;(
    &amp;mut self,
    readiness: calloop::Readiness,
    token: calloop::Token,
    mut callback: F,
) -&gt; io::Result&lt;()&gt;
where
    F: FnMut(Self::Event, &amp;mut Self::Metadata) -&gt; Self::Ret,
{
    // We were woken up on startup/registration.
    if token.sub_id == Self::ID_WAKER {
        self.wake_ping_receiver
            .process_events(readiness, token, |_, _| {})?;
    }
    // We received a message over the MPSC channel.
    else if token.sub_id == Self::ID_CHANNEL {
        let outbox = &amp;mut self.outbox;

        self.mpsc_receiver
            .process_events(readiness, token, |evt, _| {
                if let calloop::channel::Event::Msg(msg) = evt {
                    outbox.push_back(msg);
                }
            })?;
    }

	// Always process any pending zsocket events.

    let events = self.socket.get_events()?;

    if events.contains(zmq::POLLOUT) {
        if let Some(parts) = self.outbox.pop_front() {
            self.socket
                .send_multipart(parts, 0)?;
        }
    }

    if events.contains(zmq::POLLIN) {
        let messages = self.socket.recv_multipart(0)?;
        callback(messages, &amp;mut ())?;
    }

    Ok(())
}
</code></pre>
<p>There is one more issue to take care of, and it's got nothing to do with Calloop. We still haven't fully dealt with ZeroMQ's edge-triggered nature.</p>
<p>Consider this situation:</p>
<ul>
<li>We create a REQ zsocket. These are intended to be used in strict send/receive/send/receive/etc. sequence.</li>
<li>We wrap it in our <code>ZeroMQSource</code> and add that to our loop.</li>
<li>We send a message.</li>
</ul>
<p>If we do this, it's possible we'll never actually <em>receive</em> any replies that are sent to our zsocket! Why? Because:</p>
<ul>
<li>we read the events on the socket into <code>events</code></li>
<li>then we send a message on the socket</li>
<li>another process sends a reply so quickly, it arrives more or less immediately</li>
<li>then we use the same <code>events</code> to check if the socket is readable</li>
<li>then we exit</li>
</ul>
<p>The zsocket will change from writeable to readable before we leave <code>process_events()</code>. So the &quot;interface&quot; file descriptor will become readable again. But because it is edge triggered, it will not wake up our event source after we leave <code>process_events()</code>. So our source will not wake up again (at least, not due to the <code>self.socket</code> event source).</p>
<p>For <em>this specific example</em>, it will suffice to re-read the zsocket events in between the <code>if</code> statements. Then when we get to the second <code>events</code> check, it will indeed contain <code>zmq::POLLIN</code> and receive the pending message. But this is not good enough for the general case! If we replace REQ with REP above, we'll get the opposite problem: our first check (for <code>POLLOUT</code>) will be false. Our second check (<code>POLLIN</code>) will be true. We'll receive a message, leave <code>process_events()</code>, and never wake up again.</p>
<p>The full solution is to recognise that any user action on a ZeroMQ socket can cause the pending events to change, or just to remain active, without re-triggering the &quot;interface&quot; file descriptor. So we need to (a) do this repeatedly and (b) keep track of when we have or haven't performed an action on the zsocket. Here's one way to do it:</p>
<pre><code class="language-rust noplayground">loop {
    let events = self.socket.get_events()?;
    let mut used_socket = false;

    if events.contains(zmq::POLLOUT) {
        if let Some(parts) = self.outbox.pop_front() {
            self.socket
                .as_ref()
                .send_multipart(parts, 0)?;
            used_socket = true;
        }
    }

    if events.contains(zmq::POLLIN) {
        let messages = self.socket.recv_multipart(0)?;
        used_socket = true;

        callback(messages, &amp;mut ())?;
    }

    if !used_socket {
        break;
    }
}
</code></pre>
<p>Now we have a flag that we set if, and only if, we call a send or receive method on the zsocket. If that flag is set at the end of the loop, we go around again.</p>
<blockquote>
<h2 id="greediness"><a class="header" href="#greediness">Greediness</a></h2>
<p>Remember my disclaimer at the start of the chapter, about this code being &quot;greedy&quot;? This is what I mean. This loop will run until the entire message queue is empty, so if it has a lot of messages in it, any other sources in our event loop will not be run until this loop is finished.</p>
<p>An alternative approach is to use more state to determine whether we want to run again on the next loop iteration (perhaps using the ping source), so that Calloop can run any other sources in between individual messages being received.</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="the-full-zeromq-event-source-code"><a class="header" href="#the-full-zeromq-event-source-code">The full ZeroMQ event source code</a></h1>
<p>This is the full source code for a Calloop event source based on a ZeroMQ socket. You might find it useful as a kind of reference. Please read the <a href="ch03-00-a-full-example-zeromq.html#disclaimer">disclaimer at the start of this chapter</a> if you skipped straight here!</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! A Calloop event source implementation for ZeroMQ sockets.

use std::{collections, io};

/// A Calloop event source that contains a ZeroMQ socket (of any kind) and a
/// Calloop MPSC channel for sending over it.
///
/// The basic interface is:
/// - create a zmq::Socket for your ZeroMQ socket
/// - use `ZeroMQSource::from_socket()` to turn it into a Calloop event source
///   (plus the sending end of the channel)
/// - queue messages to be sent by sending them on the sending end of the MPSC
///   channel
/// - add the event source to the Calloop event loop with a callback to handle
///   reading
/// - the sending end of the MPSC channel can be cloned and sent across threads
///   if necessary
///
/// This type is parameterised by `T`:
///
///     T where T: IntoIterator, T::Item: Into&lt;zmq::Message&gt;
//
/// This means that `T` is anything that can be converted to an iterator, and
/// the items in the iterator are anything that can be converted to a
/// `zmq::Message`. So eg. a `Vec&lt;String&gt;` would work.
///
/// The callback is called whenever the underlying socket becomes readable. It
/// is called with a vec of byte sequences (`Vec&lt;Vec&lt;u8&gt;&gt;`) and the event loop
/// data set by the user.
///
/// Note about why the read data is a vec of multipart message parts: we don't
/// know what kind of socket this is, or what will be sent, so the most general
/// thing we can do is receive the entirety of a multipart message and call the
/// user callback with the whole set. Usually the number of parts in a multipart
/// message will be one, but the code will work just the same when it's not.
///
/// This event source also allows you to use different event sources to publish
/// messages over the same writeable ZeroMQ socket (usually PUB or PUSH).
/// Messages should be sent over the Calloop MPSC channel sending end. This end
/// can be cloned and used by multiple senders.

pub struct ZeroMQSource&lt;T&gt;
where
    T: IntoIterator,
    T::Item: Into&lt;zmq::Message&gt;,
{
    // Calloop components.
    /// Event source for ZeroMQ socket.
    socket_source: calloop::generic::Generic&lt;calloop::generic::Fd&gt;,

    /// Event source for channel.
    mpsc_receiver: calloop::channel::Channel&lt;T&gt;,

    /// Because the ZeroMQ socket is edge triggered, we need a way to &quot;wake&quot; the
    /// event source upon (re-)registration. We do this with a separate
    /// `calloop::ping::Ping` source.
    wake_ping_receiver: calloop::ping::PingSource,

    /// Sending end of the ping source.
    wake_ping_sender: calloop::ping::Ping,

    // ZeroMQ socket.
    /// The underlying ZeroMQ socket that we're proxying things to.
    socket: zmq::Socket,

    /// FIFO queue for the messages to be published.
    outbox: collections::VecDeque&lt;T&gt;,
}

impl&lt;T&gt; ZeroMQSource&lt;T&gt;
where
    T: IntoIterator,
    T::Item: Into&lt;zmq::Message&gt;,
{
    const ID_CHANNEL: u32 = 1;
    const ID_SOCKET: u32 = 2;
    const ID_WAKER: u32 = 3;

    // Converts a `zmq::Socket` into a `ZeroMQSource` plus the sending end of an
    // MPSC channel to enqueue outgoing messages.
    pub fn from_socket(socket: zmq::Socket) -&gt; io::Result&lt;(Self, calloop::channel::Sender&lt;T&gt;)&gt; {
        let (mpsc_sender, mpsc_receiver) = calloop::channel::channel();
        let (wake_ping_sender, wake_ping_receiver) = calloop::ping::make_ping()?;

        let fd = socket.get_fd()?;

        let socket_source =
            calloop::generic::Generic::from_fd(fd, calloop::Interest::READ, calloop::Mode::Edge);

        Ok((
            Self {
                socket,
                socket_source,
                mpsc_receiver,
                wake_ping_receiver,
                wake_ping_sender,
                outbox: collections::VecDeque::new(),
            },
            mpsc_sender,
        ))
    }
}

/// This event source runs for three events:
///
/// 1. The event source was registered. It is forced to run so that any pending
///    events on the socket are processed.
///
/// 2. A message was sent over the MPSC channel. In this case we put it in the
///    internal queue.
///
/// 3. The ZeroMQ socket is readable. For this, we read off a complete multipart
///    message and call the user callback with it.
///
/// The callback provided to `process_events()` may be called multiple times
/// within a single call to `process_events()`.
impl&lt;T&gt; calloop::EventSource for ZeroMQSource&lt;T&gt;
where
    T: IntoIterator,
    T::Item: Into&lt;zmq::Message&gt;,
{
    type Event = Vec&lt;Vec&lt;u8&gt;&gt;;
    type Metadata = ();
    type Ret = io::Result&lt;()&gt;;

    fn process_events&lt;F&gt;(
        &amp;mut self,
        readiness: calloop::Readiness,
        token: calloop::Token,
        mut callback: F,
    ) -&gt; io::Result&lt;()&gt;
    where
        F: FnMut(Self::Event, &amp;mut Self::Metadata) -&gt; Self::Ret,
    {
        // We were woken up on startup/registration.
        if token.sub_id == Self::ID_WAKER {
            self.wake_ping_receiver
                .process_events(readiness, token, |_, _| {})?;
        } else if token.sub_id == Self::ID_CHANNEL {
            let outbox = &amp;mut self.outbox;

            self.mpsc_receiver
                .process_events(readiness, token, |evt, _| {
                    if let calloop::channel::Event::Msg(msg) = evt {
                        outbox.push_back(msg);
                    }
                })?;
        }

        // The ZeroMQ file descriptor is edge triggered. This means that if (a)
        // messages are added to the queue before registration, or (b) the
        // socket became writeable before messages were enqueued, we will need
        // to run the loop below. Hence, it always runs if this event source
        // fires.

        loop {
            // According to the docs, the edge-triggered FD will not change
            // state if a socket goes directly from being readable to being
            // writeable (or vice-versa) without there being an in-between point
            // where there are no events. This can happen as a result of sending
            // or receiving on the socket while processing such an event. The
            // &quot;used_socket&quot; flag below tracks whether we perform an operation
            // on the socket that warrants reading the events again.
            let events = self.socket.get_events()?;
            let mut used_socket = false;

            if events.contains(zmq::POLLOUT) {
                if let Some(parts) = self.outbox.pop_front() {
                    self.socket.send_multipart(parts, 0)?;
                    used_socket = true;
                }
            }

            if events.contains(zmq::POLLIN) {
                // Batch up multipart messages. ZeroMQ guarantees atomic message
                // sending, which includes all parts of a multipart message.
                let messages = self.socket.recv_multipart(0)?;
                used_socket = true;

                // Capture and report errors from the callback, but don't propagate
                // them up.
                callback(messages, &amp;mut ())?;
            }

            if !used_socket {
                break;
            }
        }

        Ok(())
    }

    fn register(&amp;mut self, poll: &amp;mut calloop::Poll, token: calloop::Token) -&gt; io::Result&lt;()&gt; {
        let tk_socket = token.with_sub_id(Self::ID_SOCKET);
        let tk_channel = token.with_sub_id(Self::ID_CHANNEL);
        let tk_waker = token.with_sub_id(Self::ID_WAKER);

        self.socket_source.register(poll, tk_socket)?;
        self.mpsc_receiver.register(poll, tk_channel)?;
        self.wake_ping_receiver.register(poll, tk_waker)?;

        self.wake_ping_sender.ping();

        Ok(())
    }

    fn reregister(&amp;mut self, poll: &amp;mut calloop::Poll, token: calloop::Token) -&gt; io::Result&lt;()&gt; {
        let tk_socket = token.with_sub_id(Self::ID_SOCKET);
        let tk_channel = token.with_sub_id(Self::ID_CHANNEL);
        let tk_waker = token.with_sub_id(Self::ID_WAKER);

        self.socket_source.reregister(poll, tk_socket)?;
        self.mpsc_receiver.reregister(poll, tk_channel)?;
        self.wake_ping_receiver.reregister(poll, tk_waker)?;

        self.wake_ping_sender.ping();

        Ok(())
    }

    fn unregister(&amp;mut self, poll: &amp;mut calloop::Poll) -&gt; io::Result&lt;()&gt; {
        self.socket_source.unregister(poll)?;
        self.mpsc_receiver.unregister(poll)?;
        self.wake_ping_receiver.unregister(poll)?;
        Ok(())
    }
}

impl&lt;T&gt; Drop for ZeroMQSource&lt;T&gt;
where
    T: IntoIterator,
    T::Item: Into&lt;zmq::Message&gt;,
{
    fn drop(&amp;mut self) {
        // This is one way to stop socket code (especially PUSH sockets) hanging
        // at the end of any blocking functions.
        //
        // - https://stackoverflow.com/a/38338578/188535
        // - http://api.zeromq.org/4-0:zmq-ctx-term
        self.socket.set_linger(0).ok();
        self.socket.set_rcvtimeo(0).ok();
        self.socket.set_sndtimeo(0).ok();

        // Double result because (a) possible failure on call and (b) possible
        // failure decoding.
        if let Ok(Ok(last_endpoint)) = self.socket.get_last_endpoint() {
            self.socket.disconnect(&amp;last_endpoint).ok();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Dependencies are only <code>calloop</code> and <code>zmq</code>:</p>
<pre><code class="language-toml">[dependencies]
calloop = &quot;0.8&quot;
zmq = &quot;0.9&quot;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
