<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A simple example - A Guide to Calloop</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="ch00-00-where-to-start.html">Where to start</a></li><li class="chapter-item expanded "><a href="ch01-00-how-an-event-loop-works.html"><strong aria-hidden="true">1.</strong> How an event loop works</a></li><li class="chapter-item expanded "><a href="ch02-00-a-simple-example.html" class="active"><strong aria-hidden="true">2.</strong> A simple example</a></li><li class="chapter-item expanded "><a href="ch03-00-a-full-example-zeromq.html"><strong aria-hidden="true">3.</strong> A full example: ZeroMQ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-composition.html"><strong aria-hidden="true">3.1.</strong> Composition</a></li><li class="chapter-item expanded "><a href="ch03-02-creating-our-source-part-1-our-types.html"><strong aria-hidden="true">3.2.</strong> Creating our source, part I: our types</a></li><li class="chapter-item expanded "><a href="ch03-03-creating-our-source-part-2-setup-methods.html"><strong aria-hidden="true">3.3.</strong> Creating our source, part II: setup methods</a></li><li class="chapter-item expanded "><a href="ch03-04-creating-our-source-part-3-processing-events-almost.html"><strong aria-hidden="true">3.4.</strong> Creating our source, part III: processing events (almost)</a></li><li class="chapter-item expanded "><a href="ch03-05-creating-our-source-part-4-processing-events-really.html"><strong aria-hidden="true">3.5.</strong> Creating our source, part IV: processing events (really)</a></li><li class="chapter-item expanded "><a href="ch03-06-the-full-zeromq-event-source-code.html"><strong aria-hidden="true">3.6.</strong> The full ZeroMQ event source code</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">A Guide to Calloop</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/detly/calloop/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="a-simple-example"><a class="header" href="#a-simple-example">A simple example</a></h1>
<p>The simplest way to use Calloop is to create the event sources it provides, and add them to the event loop with a callback function. When the event source has new events to process, your callback will be called.</p>
<p>Let's create a program that waits for five seconds, prints a message, and exits. If you've already read the <code>README</code> file or <a href="api">API docs</a>, this will look familiar.</p>
<h2 id="the-timer-event-source"><a class="header" href="#the-timer-event-source">The timer event source</a></h2>
<p>The first thing we need is an event source — that is, a type that implements the trait <code>calloop::EventSource</code>. If we look under <code>calloop::timer</code> we'll see the appropriately named <code>Timer</code>.</p>
<p><code>Timer</code> follows a pattern you'll see used for almost all event sources in Calloop. There is an event source (<code>Timer</code>) that is inserted into the loop. But there is also some other type (in this case, <code>TimerHandle</code>) that allows you to control or configure that source even after the loop has taken ownership of the source itself. For example:</p>
<ul>
<li>
<p>there is an MPSC (multiple producer, single consumer) channel that acts as an event source; the &quot;control&quot; end is simply the sending end of the channel</p>
</li>
<li>
<p>there is an <code>async</code> executor that acts as an event source; it is created along with a scheduler which lets you add <code>Future</code>s</p>
</li>
<li>
<p>the <code>Timer</code> can give you a <code>TimerHandle</code>, which lets you set or cancel timeouts</p>
</li>
</ul>
<p>So with <code>use calloop::timer::Timer</code> at the top of our <code>.rs</code> file, we just need to do:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use calloop::{timer::Timer, EventLoop, LoopSignal};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut event_loop: EventLoop&lt;LoopSignal&gt; =
</span><span class="boring">        EventLoop::try_new()
</span><span class="boring">            .expect(&quot;Failed to initialize the event loop!&quot;);
</span><span class="boring">
</span>    let source = Timer::new()
        .expect(&quot;Failed to create timer event source!&quot;);

    let timer_handle = source.handle();
    timer_handle
        .add_timeout(Duration::from_secs(5), &quot;Timeout reached!&quot;);
<span class="boring">
</span><span class="boring">    let handle = event_loop.handle();
</span><span class="boring">
</span><span class="boring">    handle
</span><span class="boring">        .insert_source(
</span><span class="boring">            source,
</span><span class="boring">            |event, _metadata, shared_data| {
</span><span class="boring">                println!(&quot;Event fired: {}&quot;, event);
</span><span class="boring">                shared_data.stop();
</span><span class="boring">            },
</span><span class="boring">        )
</span><span class="boring">        .expect(&quot;Failed to insert event source!&quot;);
</span><span class="boring">
</span><span class="boring">    let mut shared_data = event_loop.get_signal();
</span><span class="boring">
</span><span class="boring">    event_loop
</span><span class="boring">        .run(None, &amp;mut shared_data, |_shared_data| {})
</span><span class="boring">        .expect(&quot;Error during event loop!&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>Many methods in Calloop return a <code>Result</code> because creating these sources is inherently risky — most event sources require some kind of underlying operating system resource, which can potentially be exhausted. You will have to decide how to handle such errors.</p>
<p>An extremely important thing to note about our timer handle here is that we are not constrained to use it before we run our event loop. We may call methods on it from other event callbacks, we may clone it and even use it in other threads or futures to dynamically control the <code>Timer</code> that is now part of the event loop.</p>
<h2 id="calloops-type-parameters"><a class="header" href="#calloops-type-parameters">Calloop's type parameters</a></h2>
<p>The second argument to <code>add_timeout()</code> deserves extra attention. Calloop has a few different type parameters that you'll need to know about to use it properly. The two most important are:</p>
<ul>
<li>
<p>The event loop itself, <code>EventLoop</code>, is parameterised by the type of the shared data that all callbacks receive. This will probably correspond to the &quot;high level&quot; state of your program.</p>
</li>
<li>
<p>Event sources ie. implementations of <code>EventSource</code>, have an associated type <code>Event</code>. This differs from source to source, and always relates to the &quot;control side&quot; of the source.</p>
</li>
</ul>
<p>In the case of a timer, <code>Timer::Event</code> is the type of data that you give to the handle: here it is <code>&amp;'static str</code>. But what about <code>EventLoop</code>'s type parameter? Well, since we want to exit the program after the timer fires, the high level &quot;state&quot; of our program is simply whether our loop is running or not. This is easily controlled by the <code>LoopSignal</code> value that <code>EventLoop::get_signal()</code> provides us, which has a <code>stop()</code> method. So let's make this our shared state:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use calloop::{timer::Timer, EventLoop, LoopSignal};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let mut event_loop: EventLoop&lt;LoopSignal&gt; =
        EventLoop::try_new()
            .expect(&quot;Failed to initialize the event loop!&quot;);
<span class="boring">
</span><span class="boring">    let source = Timer::new()
</span><span class="boring">        .expect(&quot;Failed to create timer event source!&quot;);
</span><span class="boring">
</span><span class="boring">    let timer_handle = source.handle();
</span><span class="boring">    timer_handle
</span><span class="boring">        .add_timeout(Duration::from_secs(5), &quot;Timeout reached!&quot;);
</span><span class="boring">
</span><span class="boring">    let handle = event_loop.handle();
</span><span class="boring">
</span><span class="boring">    handle
</span><span class="boring">        .insert_source(
</span><span class="boring">            source,
</span><span class="boring">            |event, _metadata, shared_data| {
</span><span class="boring">                println!(&quot;Event fired: {}&quot;, event);
</span><span class="boring">                shared_data.stop();
</span><span class="boring">            },
</span><span class="boring">        )
</span><span class="boring">        .expect(&quot;Failed to insert event source!&quot;);
</span><span class="boring">
</span><span class="boring">    let mut shared_data = event_loop.get_signal();
</span><span class="boring">
</span><span class="boring">    event_loop
</span><span class="boring">        .run(None, &amp;mut shared_data, |_shared_data| {})
</span><span class="boring">        .expect(&quot;Error during event loop!&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>This is just the type annotation — something that Rust could infer itself, but it's often helpful to make it explicit here to avoid confusing error messages if you get it wrong in callbacks or method calls. The actual data is provided when we run the loop:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use calloop::{timer::Timer, EventLoop, LoopSignal};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut event_loop: EventLoop&lt;LoopSignal&gt; =
</span><span class="boring">        EventLoop::try_new()
</span><span class="boring">            .expect(&quot;Failed to initialize the event loop!&quot;);
</span><span class="boring">
</span><span class="boring">    let source = Timer::new()
</span><span class="boring">        .expect(&quot;Failed to create timer event source!&quot;);
</span><span class="boring">
</span><span class="boring">    let timer_handle = source.handle();
</span><span class="boring">    timer_handle
</span><span class="boring">        .add_timeout(Duration::from_secs(5), &quot;Timeout reached!&quot;);
</span><span class="boring">
</span><span class="boring">    let handle = event_loop.handle();
</span><span class="boring">
</span><span class="boring">    handle
</span><span class="boring">        .insert_source(
</span><span class="boring">            source,
</span><span class="boring">            |event, _metadata, shared_data| {
</span><span class="boring">                println!(&quot;Event fired: {}&quot;, event);
</span><span class="boring">                shared_data.stop();
</span><span class="boring">            },
</span><span class="boring">        )
</span><span class="boring">        .expect(&quot;Failed to insert event source!&quot;);
</span><span class="boring">
</span>    let mut shared_data = event_loop.get_signal();

    event_loop
        .run(None, &amp;mut shared_data, |_shared_data| {})
        .expect(&quot;Error during event loop!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>The callback provided in the <code>run()</code> method is for when the loop is idle, which we're not using here.</p>
<h2 id="adding-sources-to-the-loop"><a class="header" href="#adding-sources-to-the-loop">Adding sources to the loop</a></h2>
<p>We have an event source, we have our shared data, and we know how to start our loop running. All that is left is to learn how to combine these things:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">use calloop::{timer::Timer, EventLoop, LoopSignal};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut event_loop: EventLoop&lt;LoopSignal&gt; =
</span><span class="boring">        EventLoop::try_new()
</span><span class="boring">            .expect(&quot;Failed to initialize the event loop!&quot;);
</span><span class="boring">
</span><span class="boring">    let source = Timer::new()
</span><span class="boring">        .expect(&quot;Failed to create timer event source!&quot;);
</span><span class="boring">
</span><span class="boring">    let timer_handle = source.handle();
</span><span class="boring">    timer_handle
</span><span class="boring">        .add_timeout(Duration::from_secs(5), &quot;Timeout reached!&quot;);
</span><span class="boring">
</span>    let handle = event_loop.handle();

    handle
        .insert_source(
            source,
            |event, _metadata, shared_data| {
                println!(&quot;Event fired: {}&quot;, event);
                shared_data.stop();
            },
        )
        .expect(&quot;Failed to insert event source!&quot;);
<span class="boring">
</span><span class="boring">    let mut shared_data = event_loop.get_signal();
</span><span class="boring">
</span><span class="boring">    event_loop
</span><span class="boring">        .run(None, &amp;mut shared_data, |_shared_data| {})
</span><span class="boring">        .expect(&quot;Error during event loop!&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>Breaking this down:</p>
<ul>
<li>
<p>We obtain a handle from the event loop. Much like the timer handle above, this is a separate type from the event loop and allows us to insert events sources. Event sources can be added to the loop from eg. your main function, within event callbacks, and futures. Note that it is <em>not</em> safe to pass across threads!</p>
</li>
<li>
<p>We insert the source using <code>LoopHandle::insert_source()</code>.</p>
</li>
<li>
<p>When we insert the source we also provide a callback that will be called on every event generated by the event source. This callback will take the event specific data (our <code>&amp;'static str</code>), some source-specific data (the timer's handle) and the shared loop data (a <code>LoopSignal</code>).</p>
</li>
</ul>
<p>Our callback does the two things we want to do when five seconds have elapsed: print a message, and stop the loop.</p>
<p>Once the loop stops, the <code>run()</code> call will exit and so will <code>main()</code>.</p>
<h2 id="the-whole-program"><a class="header" href="#the-whole-program">The whole program</a></h2>
<p>Putting it all together, we have:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use calloop::{timer::Timer, EventLoop, LoopSignal};

fn main() {
    let mut event_loop: EventLoop&lt;LoopSignal&gt; =
        EventLoop::try_new()
            .expect(&quot;Failed to initialize the event loop!&quot;);

    let source = Timer::new()
        .expect(&quot;Failed to create timer event source!&quot;);

    let timer_handle = source.handle();
    timer_handle
        .add_timeout(Duration::from_secs(5), &quot;Timeout reached!&quot;);

    let handle = event_loop.handle();

    handle
        .insert_source(
            source,
            |event, _metadata, shared_data| {
                println!(&quot;Event fired: {}&quot;, event);
                shared_data.stop();
            },
        )
        .expect(&quot;Failed to insert event source!&quot;);

    let mut shared_data = event_loop.get_signal();

    event_loop
        .run(None, &amp;mut shared_data, |_shared_data| {})
        .expect(&quot;Error during event loop!&quot;);
}
</code></pre></pre>
<h2 id="what-next"><a class="header" href="#what-next">What next?</a></h2>
<p>Of course, this is all a bit more wordy than simply <code>std::thread::sleep()</code>, so what have we achieved?</p>
<p>The next couple of chapters will show how we can create our own event sources through <em>composition</em>, and how to use handles and events in more complex ways.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch01-00-how-an-event-loop-works.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch03-00-a-full-example-zeromq.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch01-00-how-an-event-loop-works.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch03-00-a-full-example-zeromq.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
